// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dgtdll.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dgtdll_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_dgtdll_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dgtdll_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dgtdll_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_dgtdll_2eproto;
namespace dgt {
class BoolRequest;
struct BoolRequestDefaultTypeInternal;
extern BoolRequestDefaultTypeInternal _BoolRequest_default_instance_;
class CallbackIIC;
struct CallbackIICDefaultTypeInternal;
extern CallbackIICDefaultTypeInternal _CallbackIIC_default_instance_;
class CallbackResponse;
struct CallbackResponseDefaultTypeInternal;
extern CallbackResponseDefaultTypeInternal _CallbackResponse_default_instance_;
class ClockMessageRequest;
struct ClockMessageRequestDefaultTypeInternal;
extern ClockMessageRequestDefaultTypeInternal _ClockMessageRequest_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class IntRequest;
struct IntRequestDefaultTypeInternal;
extern IntRequestDefaultTypeInternal _IntRequest_default_instance_;
class IntResponse;
struct IntResponseDefaultTypeInternal;
extern IntResponseDefaultTypeInternal _IntResponse_default_instance_;
class SetNRunRequest;
struct SetNRunRequestDefaultTypeInternal;
extern SetNRunRequestDefaultTypeInternal _SetNRunRequest_default_instance_;
class StringRequest;
struct StringRequestDefaultTypeInternal;
extern StringRequestDefaultTypeInternal _StringRequest_default_instance_;
}  // namespace dgt
PROTOBUF_NAMESPACE_OPEN
template <>
::dgt::BoolRequest* Arena::CreateMaybeMessage<::dgt::BoolRequest>(Arena*);
template <>
::dgt::CallbackIIC* Arena::CreateMaybeMessage<::dgt::CallbackIIC>(Arena*);
template <>
::dgt::CallbackResponse* Arena::CreateMaybeMessage<::dgt::CallbackResponse>(Arena*);
template <>
::dgt::ClockMessageRequest* Arena::CreateMaybeMessage<::dgt::ClockMessageRequest>(Arena*);
template <>
::dgt::Empty* Arena::CreateMaybeMessage<::dgt::Empty>(Arena*);
template <>
::dgt::IntRequest* Arena::CreateMaybeMessage<::dgt::IntRequest>(Arena*);
template <>
::dgt::IntResponse* Arena::CreateMaybeMessage<::dgt::IntResponse>(Arena*);
template <>
::dgt::SetNRunRequest* Arena::CreateMaybeMessage<::dgt::SetNRunRequest>(Arena*);
template <>
::dgt::StringRequest* Arena::CreateMaybeMessage<::dgt::StringRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace dgt {

// ===================================================================


// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:dgt.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dgt.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class IntRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.IntRequest) */ {
 public:
  inline IntRequest() : IntRequest(nullptr) {}
  ~IntRequest() override;
  explicit PROTOBUF_CONSTEXPR IntRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntRequest(const IntRequest& from);
  IntRequest(IntRequest&& from) noexcept
    : IntRequest() {
    *this = ::std::move(from);
  }

  inline IntRequest& operator=(const IntRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntRequest& operator=(IntRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntRequest* internal_default_instance() {
    return reinterpret_cast<const IntRequest*>(
               &_IntRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IntRequest& a, IntRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IntRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntRequest& from) {
    IntRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.IntRequest";
  }
  protected:
  explicit IntRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dgt.IntRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class BoolRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.BoolRequest) */ {
 public:
  inline BoolRequest() : BoolRequest(nullptr) {}
  ~BoolRequest() override;
  explicit PROTOBUF_CONSTEXPR BoolRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolRequest(const BoolRequest& from);
  BoolRequest(BoolRequest&& from) noexcept
    : BoolRequest() {
    *this = ::std::move(from);
  }

  inline BoolRequest& operator=(const BoolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolRequest& operator=(BoolRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolRequest* internal_default_instance() {
    return reinterpret_cast<const BoolRequest*>(
               &_BoolRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BoolRequest& a, BoolRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolRequest& from) {
    BoolRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.BoolRequest";
  }
  protected:
  explicit BoolRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value() ;
  bool value() const;
  void set_value(bool value);

  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dgt.BoolRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class StringRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.StringRequest) */ {
 public:
  inline StringRequest() : StringRequest(nullptr) {}
  ~StringRequest() override;
  explicit PROTOBUF_CONSTEXPR StringRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringRequest(const StringRequest& from);
  StringRequest(StringRequest&& from) noexcept
    : StringRequest() {
    *this = ::std::move(from);
  }

  inline StringRequest& operator=(const StringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringRequest& operator=(StringRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringRequest* internal_default_instance() {
    return reinterpret_cast<const StringRequest*>(
               &_StringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StringRequest& a, StringRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StringRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringRequest& from) {
    StringRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.StringRequest";
  }
  protected:
  explicit StringRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:dgt.StringRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class ClockMessageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.ClockMessageRequest) */ {
 public:
  inline ClockMessageRequest() : ClockMessageRequest(nullptr) {}
  ~ClockMessageRequest() override;
  explicit PROTOBUF_CONSTEXPR ClockMessageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClockMessageRequest(const ClockMessageRequest& from);
  ClockMessageRequest(ClockMessageRequest&& from) noexcept
    : ClockMessageRequest() {
    *this = ::std::move(from);
  }

  inline ClockMessageRequest& operator=(const ClockMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClockMessageRequest& operator=(ClockMessageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClockMessageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClockMessageRequest* internal_default_instance() {
    return reinterpret_cast<const ClockMessageRequest*>(
               &_ClockMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClockMessageRequest& a, ClockMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ClockMessageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClockMessageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClockMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClockMessageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClockMessageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClockMessageRequest& from) {
    ClockMessageRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClockMessageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.ClockMessageRequest";
  }
  protected:
  explicit ClockMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // int32 time = 2;
  void clear_time() ;
  ::int32_t time() const;
  void set_time(::int32_t value);

  private:
  ::int32_t _internal_time() const;
  void _internal_set_time(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dgt.ClockMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::int32_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class SetNRunRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.SetNRunRequest) */ {
 public:
  inline SetNRunRequest() : SetNRunRequest(nullptr) {}
  ~SetNRunRequest() override;
  explicit PROTOBUF_CONSTEXPR SetNRunRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetNRunRequest(const SetNRunRequest& from);
  SetNRunRequest(SetNRunRequest&& from) noexcept
    : SetNRunRequest() {
    *this = ::std::move(from);
  }

  inline SetNRunRequest& operator=(const SetNRunRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetNRunRequest& operator=(SetNRunRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetNRunRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetNRunRequest* internal_default_instance() {
    return reinterpret_cast<const SetNRunRequest*>(
               &_SetNRunRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetNRunRequest& a, SetNRunRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetNRunRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetNRunRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetNRunRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetNRunRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetNRunRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetNRunRequest& from) {
    SetNRunRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetNRunRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.SetNRunRequest";
  }
  protected:
  explicit SetNRunRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParam1FieldNumber = 1,
    kParam2FieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // string param1 = 1;
  void clear_param1() ;
  const std::string& param1() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_param1(Arg_&& arg, Args_... args);
  std::string* mutable_param1();
  PROTOBUF_NODISCARD std::string* release_param1();
  void set_allocated_param1(std::string* ptr);

  private:
  const std::string& _internal_param1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param1(
      const std::string& value);
  std::string* _internal_mutable_param1();

  public:
  // string param2 = 2;
  void clear_param2() ;
  const std::string& param2() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_param2(Arg_&& arg, Args_... args);
  std::string* mutable_param2();
  PROTOBUF_NODISCARD std::string* release_param2();
  void set_allocated_param2(std::string* ptr);

  private:
  const std::string& _internal_param2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param2(
      const std::string& value);
  std::string* _internal_mutable_param2();

  public:
  // int32 time = 3;
  void clear_time() ;
  ::int32_t time() const;
  void set_time(::int32_t value);

  private:
  ::int32_t _internal_time() const;
  void _internal_set_time(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dgt.SetNRunRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param2_;
    ::int32_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class IntResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.IntResponse) */ {
 public:
  inline IntResponse() : IntResponse(nullptr) {}
  ~IntResponse() override;
  explicit PROTOBUF_CONSTEXPR IntResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntResponse(const IntResponse& from);
  IntResponse(IntResponse&& from) noexcept
    : IntResponse() {
    *this = ::std::move(from);
  }

  inline IntResponse& operator=(const IntResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntResponse& operator=(IntResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntResponse* internal_default_instance() {
    return reinterpret_cast<const IntResponse*>(
               &_IntResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IntResponse& a, IntResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IntResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntResponse& from) {
    IntResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.IntResponse";
  }
  protected:
  explicit IntResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dgt.IntResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class CallbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.CallbackResponse) */ {
 public:
  inline CallbackResponse() : CallbackResponse(nullptr) {}
  ~CallbackResponse() override;
  explicit PROTOBUF_CONSTEXPR CallbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbackResponse(const CallbackResponse& from);
  CallbackResponse(CallbackResponse&& from) noexcept
    : CallbackResponse() {
    *this = ::std::move(from);
  }

  inline CallbackResponse& operator=(const CallbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbackResponse& operator=(CallbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallbackResponse& default_instance() {
    return *internal_default_instance();
  }
  enum CallbackDataCase {
    kStringData = 2,
    kIntData = 3,
    kBoolData = 4,
    kIicData = 5,
    CALLBACK_DATA_NOT_SET = 0,
  };

  static inline const CallbackResponse* internal_default_instance() {
    return reinterpret_cast<const CallbackResponse*>(
               &_CallbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CallbackResponse& a, CallbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CallbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbackResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallbackResponse& from) {
    CallbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.CallbackResponse";
  }
  protected:
  explicit CallbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallbackNameFieldNumber = 1,
    kStringDataFieldNumber = 2,
    kIntDataFieldNumber = 3,
    kBoolDataFieldNumber = 4,
    kIicDataFieldNumber = 5,
  };
  // string callback_name = 1;
  void clear_callback_name() ;
  const std::string& callback_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_callback_name(Arg_&& arg, Args_... args);
  std::string* mutable_callback_name();
  PROTOBUF_NODISCARD std::string* release_callback_name();
  void set_allocated_callback_name(std::string* ptr);

  private:
  const std::string& _internal_callback_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callback_name(
      const std::string& value);
  std::string* _internal_mutable_callback_name();

  public:
  // string string_data = 2;
  bool has_string_data() const;
  void clear_string_data() ;
  const std::string& string_data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_data(Arg_&& arg, Args_... args);
  std::string* mutable_string_data();
  PROTOBUF_NODISCARD std::string* release_string_data();
  void set_allocated_string_data(std::string* ptr);

  private:
  const std::string& _internal_string_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_data(
      const std::string& value);
  std::string* _internal_mutable_string_data();

  public:
  // int32 int_data = 3;
  bool has_int_data() const;
  void clear_int_data() ;
  ::int32_t int_data() const;
  void set_int_data(::int32_t value);

  private:
  ::int32_t _internal_int_data() const;
  void _internal_set_int_data(::int32_t value);

  public:
  // bool bool_data = 4;
  bool has_bool_data() const;
  void clear_bool_data() ;
  bool bool_data() const;
  void set_bool_data(bool value);

  private:
  bool _internal_bool_data() const;
  void _internal_set_bool_data(bool value);

  public:
  // .dgt.CallbackIIC iic_data = 5;
  bool has_iic_data() const;
  private:
  bool _internal_has_iic_data() const;

  public:
  void clear_iic_data() ;
  const ::dgt::CallbackIIC& iic_data() const;
  PROTOBUF_NODISCARD ::dgt::CallbackIIC* release_iic_data();
  ::dgt::CallbackIIC* mutable_iic_data();
  void set_allocated_iic_data(::dgt::CallbackIIC* iic_data);
  private:
  const ::dgt::CallbackIIC& _internal_iic_data() const;
  ::dgt::CallbackIIC* _internal_mutable_iic_data();
  public:
  void unsafe_arena_set_allocated_iic_data(
      ::dgt::CallbackIIC* iic_data);
  ::dgt::CallbackIIC* unsafe_arena_release_iic_data();
  void clear_callback_data();
  CallbackDataCase callback_data_case() const;
  // @@protoc_insertion_point(class_scope:dgt.CallbackResponse)
 private:
  class _Internal;
  void set_has_string_data();
  void set_has_int_data();
  void set_has_bool_data();
  void set_has_iic_data();

  inline bool has_callback_data() const;
  inline void clear_has_callback_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callback_name_;
    union CallbackDataUnion {
      constexpr CallbackDataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_data_;
      ::int32_t int_data_;
      bool bool_data_;
      ::dgt::CallbackIIC* iic_data_;
    } callback_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};// -------------------------------------------------------------------

class CallbackIIC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dgt.CallbackIIC) */ {
 public:
  inline CallbackIIC() : CallbackIIC(nullptr) {}
  ~CallbackIIC() override;
  explicit PROTOBUF_CONSTEXPR CallbackIIC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CallbackIIC(const CallbackIIC& from);
  CallbackIIC(CallbackIIC&& from) noexcept
    : CallbackIIC() {
    *this = ::std::move(from);
  }

  inline CallbackIIC& operator=(const CallbackIIC& from) {
    CopyFrom(from);
    return *this;
  }
  inline CallbackIIC& operator=(CallbackIIC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CallbackIIC& default_instance() {
    return *internal_default_instance();
  }
  static inline const CallbackIIC* internal_default_instance() {
    return reinterpret_cast<const CallbackIIC*>(
               &_CallbackIIC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CallbackIIC& a, CallbackIIC& b) {
    a.Swap(&b);
  }
  inline void Swap(CallbackIIC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CallbackIIC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CallbackIIC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CallbackIIC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CallbackIIC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CallbackIIC& from) {
    CallbackIIC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CallbackIIC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dgt.CallbackIIC";
  }
  protected:
  explicit CallbackIIC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParam3FieldNumber = 3,
    kParam1FieldNumber = 1,
    kParam2FieldNumber = 2,
  };
  // string param3 = 3;
  void clear_param3() ;
  const std::string& param3() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_param3(Arg_&& arg, Args_... args);
  std::string* mutable_param3();
  PROTOBUF_NODISCARD std::string* release_param3();
  void set_allocated_param3(std::string* ptr);

  private:
  const std::string& _internal_param3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param3(
      const std::string& value);
  std::string* _internal_mutable_param3();

  public:
  // int32 param1 = 1;
  void clear_param1() ;
  ::int32_t param1() const;
  void set_param1(::int32_t value);

  private:
  ::int32_t _internal_param1() const;
  void _internal_set_param1(::int32_t value);

  public:
  // int32 param2 = 2;
  void clear_param2() ;
  ::int32_t param2() const;
  void set_param2(::int32_t value);

  private:
  ::int32_t _internal_param2() const;
  void _internal_set_param2(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dgt.CallbackIIC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param3_;
    ::int32_t param1_;
    ::int32_t param2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dgtdll_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// IntRequest

// int32 value = 1;
inline void IntRequest::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t IntRequest::value() const {
  // @@protoc_insertion_point(field_get:dgt.IntRequest.value)
  return _internal_value();
}
inline void IntRequest::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:dgt.IntRequest.value)
}
inline ::int32_t IntRequest::_internal_value() const {
  return _impl_.value_;
}
inline void IntRequest::_internal_set_value(::int32_t value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// BoolRequest

// bool value = 1;
inline void BoolRequest::clear_value() {
  _impl_.value_ = false;
}
inline bool BoolRequest::value() const {
  // @@protoc_insertion_point(field_get:dgt.BoolRequest.value)
  return _internal_value();
}
inline void BoolRequest::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:dgt.BoolRequest.value)
}
inline bool BoolRequest::_internal_value() const {
  return _impl_.value_;
}
inline void BoolRequest::_internal_set_value(bool value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// StringRequest

// string value = 1;
inline void StringRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StringRequest::value() const {
  // @@protoc_insertion_point(field_get:dgt.StringRequest.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRequest::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dgt.StringRequest.value)
}
inline std::string* StringRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:dgt.StringRequest.value)
  return _s;
}
inline const std::string& StringRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StringRequest::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StringRequest::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* StringRequest::release_value() {
  // @@protoc_insertion_point(field_release:dgt.StringRequest.value)
  return _impl_.value_.Release();
}
inline void StringRequest::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dgt.StringRequest.value)
}

// -------------------------------------------------------------------

// ClockMessageRequest

// string message = 1;
inline void ClockMessageRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ClockMessageRequest::message() const {
  // @@protoc_insertion_point(field_get:dgt.ClockMessageRequest.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClockMessageRequest::set_message(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dgt.ClockMessageRequest.message)
}
inline std::string* ClockMessageRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:dgt.ClockMessageRequest.message)
  return _s;
}
inline const std::string& ClockMessageRequest::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ClockMessageRequest::_internal_set_message(const std::string& value) {
  ;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ClockMessageRequest::_internal_mutable_message() {
  ;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* ClockMessageRequest::release_message() {
  // @@protoc_insertion_point(field_release:dgt.ClockMessageRequest.message)
  return _impl_.message_.Release();
}
inline void ClockMessageRequest::set_allocated_message(std::string* value) {
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dgt.ClockMessageRequest.message)
}

// int32 time = 2;
inline void ClockMessageRequest::clear_time() {
  _impl_.time_ = 0;
}
inline ::int32_t ClockMessageRequest::time() const {
  // @@protoc_insertion_point(field_get:dgt.ClockMessageRequest.time)
  return _internal_time();
}
inline void ClockMessageRequest::set_time(::int32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:dgt.ClockMessageRequest.time)
}
inline ::int32_t ClockMessageRequest::_internal_time() const {
  return _impl_.time_;
}
inline void ClockMessageRequest::_internal_set_time(::int32_t value) {
  ;
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// SetNRunRequest

// string param1 = 1;
inline void SetNRunRequest::clear_param1() {
  _impl_.param1_.ClearToEmpty();
}
inline const std::string& SetNRunRequest::param1() const {
  // @@protoc_insertion_point(field_get:dgt.SetNRunRequest.param1)
  return _internal_param1();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetNRunRequest::set_param1(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.param1_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dgt.SetNRunRequest.param1)
}
inline std::string* SetNRunRequest::mutable_param1() {
  std::string* _s = _internal_mutable_param1();
  // @@protoc_insertion_point(field_mutable:dgt.SetNRunRequest.param1)
  return _s;
}
inline const std::string& SetNRunRequest::_internal_param1() const {
  return _impl_.param1_.Get();
}
inline void SetNRunRequest::_internal_set_param1(const std::string& value) {
  ;


  _impl_.param1_.Set(value, GetArenaForAllocation());
}
inline std::string* SetNRunRequest::_internal_mutable_param1() {
  ;
  return _impl_.param1_.Mutable( GetArenaForAllocation());
}
inline std::string* SetNRunRequest::release_param1() {
  // @@protoc_insertion_point(field_release:dgt.SetNRunRequest.param1)
  return _impl_.param1_.Release();
}
inline void SetNRunRequest::set_allocated_param1(std::string* value) {
  _impl_.param1_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.param1_.IsDefault()) {
          _impl_.param1_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dgt.SetNRunRequest.param1)
}

// string param2 = 2;
inline void SetNRunRequest::clear_param2() {
  _impl_.param2_.ClearToEmpty();
}
inline const std::string& SetNRunRequest::param2() const {
  // @@protoc_insertion_point(field_get:dgt.SetNRunRequest.param2)
  return _internal_param2();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SetNRunRequest::set_param2(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.param2_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dgt.SetNRunRequest.param2)
}
inline std::string* SetNRunRequest::mutable_param2() {
  std::string* _s = _internal_mutable_param2();
  // @@protoc_insertion_point(field_mutable:dgt.SetNRunRequest.param2)
  return _s;
}
inline const std::string& SetNRunRequest::_internal_param2() const {
  return _impl_.param2_.Get();
}
inline void SetNRunRequest::_internal_set_param2(const std::string& value) {
  ;


  _impl_.param2_.Set(value, GetArenaForAllocation());
}
inline std::string* SetNRunRequest::_internal_mutable_param2() {
  ;
  return _impl_.param2_.Mutable( GetArenaForAllocation());
}
inline std::string* SetNRunRequest::release_param2() {
  // @@protoc_insertion_point(field_release:dgt.SetNRunRequest.param2)
  return _impl_.param2_.Release();
}
inline void SetNRunRequest::set_allocated_param2(std::string* value) {
  _impl_.param2_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.param2_.IsDefault()) {
          _impl_.param2_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dgt.SetNRunRequest.param2)
}

// int32 time = 3;
inline void SetNRunRequest::clear_time() {
  _impl_.time_ = 0;
}
inline ::int32_t SetNRunRequest::time() const {
  // @@protoc_insertion_point(field_get:dgt.SetNRunRequest.time)
  return _internal_time();
}
inline void SetNRunRequest::set_time(::int32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:dgt.SetNRunRequest.time)
}
inline ::int32_t SetNRunRequest::_internal_time() const {
  return _impl_.time_;
}
inline void SetNRunRequest::_internal_set_time(::int32_t value) {
  ;
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// IntResponse

// int32 value = 1;
inline void IntResponse::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t IntResponse::value() const {
  // @@protoc_insertion_point(field_get:dgt.IntResponse.value)
  return _internal_value();
}
inline void IntResponse::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:dgt.IntResponse.value)
}
inline ::int32_t IntResponse::_internal_value() const {
  return _impl_.value_;
}
inline void IntResponse::_internal_set_value(::int32_t value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// CallbackResponse

// string callback_name = 1;
inline void CallbackResponse::clear_callback_name() {
  _impl_.callback_name_.ClearToEmpty();
}
inline const std::string& CallbackResponse::callback_name() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackResponse.callback_name)
  return _internal_callback_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CallbackResponse::set_callback_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.callback_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dgt.CallbackResponse.callback_name)
}
inline std::string* CallbackResponse::mutable_callback_name() {
  std::string* _s = _internal_mutable_callback_name();
  // @@protoc_insertion_point(field_mutable:dgt.CallbackResponse.callback_name)
  return _s;
}
inline const std::string& CallbackResponse::_internal_callback_name() const {
  return _impl_.callback_name_.Get();
}
inline void CallbackResponse::_internal_set_callback_name(const std::string& value) {
  ;


  _impl_.callback_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CallbackResponse::_internal_mutable_callback_name() {
  ;
  return _impl_.callback_name_.Mutable( GetArenaForAllocation());
}
inline std::string* CallbackResponse::release_callback_name() {
  // @@protoc_insertion_point(field_release:dgt.CallbackResponse.callback_name)
  return _impl_.callback_name_.Release();
}
inline void CallbackResponse::set_allocated_callback_name(std::string* value) {
  _impl_.callback_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.callback_name_.IsDefault()) {
          _impl_.callback_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dgt.CallbackResponse.callback_name)
}

// string string_data = 2;
inline bool CallbackResponse::has_string_data() const {
  return callback_data_case() == kStringData;
}
inline void CallbackResponse::set_has_string_data() {
  _impl_._oneof_case_[0] = kStringData;
}
inline void CallbackResponse::clear_string_data() {
  if (callback_data_case() == kStringData) {
    _impl_.callback_data_.string_data_.Destroy();
    clear_has_callback_data();
  }
}
inline const std::string& CallbackResponse::string_data() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackResponse.string_data)
  return _internal_string_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CallbackResponse::set_string_data(Arg_&& arg,
                                                     Args_... args) {
  if (callback_data_case() != kStringData) {
    clear_callback_data();

    set_has_string_data();
    _impl_.callback_data_.string_data_.InitDefault();
  }
  _impl_.callback_data_.string_data_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dgt.CallbackResponse.string_data)
}
inline std::string* CallbackResponse::mutable_string_data() {
  std::string* _s = _internal_mutable_string_data();
  // @@protoc_insertion_point(field_mutable:dgt.CallbackResponse.string_data)
  return _s;
}
inline const std::string& CallbackResponse::_internal_string_data() const {
  if (callback_data_case() != kStringData) {
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.callback_data_.string_data_.Get();
}
inline void CallbackResponse::_internal_set_string_data(const std::string& value) {
  if (callback_data_case() != kStringData) {
    clear_callback_data();

    set_has_string_data();
    _impl_.callback_data_.string_data_.InitDefault();
  }


  _impl_.callback_data_.string_data_.Set(value, GetArenaForAllocation());
}
inline std::string* CallbackResponse::_internal_mutable_string_data() {
  if (callback_data_case() != kStringData) {
    clear_callback_data();

    set_has_string_data();
    _impl_.callback_data_.string_data_.InitDefault();
  }
  return _impl_.callback_data_.string_data_.Mutable( GetArenaForAllocation());
}
inline std::string* CallbackResponse::release_string_data() {
  // @@protoc_insertion_point(field_release:dgt.CallbackResponse.string_data)
  if (callback_data_case() != kStringData) {
    return nullptr;
  }
  clear_has_callback_data();
  return _impl_.callback_data_.string_data_.Release();
}
inline void CallbackResponse::set_allocated_string_data(std::string* value) {
  if (has_callback_data()) {
    clear_callback_data();
  }
  if (value != nullptr) {
    set_has_string_data();
    _impl_.callback_data_.string_data_.InitAllocated(value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:dgt.CallbackResponse.string_data)
}

// int32 int_data = 3;
inline bool CallbackResponse::has_int_data() const {
  return callback_data_case() == kIntData;
}
inline void CallbackResponse::set_has_int_data() {
  _impl_._oneof_case_[0] = kIntData;
}
inline void CallbackResponse::clear_int_data() {
  if (callback_data_case() == kIntData) {
    _impl_.callback_data_.int_data_ = 0;
    clear_has_callback_data();
  }
}
inline ::int32_t CallbackResponse::int_data() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackResponse.int_data)
  return _internal_int_data();
}
inline void CallbackResponse::set_int_data(::int32_t value) {
  _internal_set_int_data(value);
  // @@protoc_insertion_point(field_set:dgt.CallbackResponse.int_data)
}
inline ::int32_t CallbackResponse::_internal_int_data() const {
  if (callback_data_case() == kIntData) {
    return _impl_.callback_data_.int_data_;
  }
  return 0;
}
inline void CallbackResponse::_internal_set_int_data(::int32_t value) {
  if (callback_data_case() != kIntData) {
    clear_callback_data();
    set_has_int_data();
  }
  _impl_.callback_data_.int_data_ = value;
}

// bool bool_data = 4;
inline bool CallbackResponse::has_bool_data() const {
  return callback_data_case() == kBoolData;
}
inline void CallbackResponse::set_has_bool_data() {
  _impl_._oneof_case_[0] = kBoolData;
}
inline void CallbackResponse::clear_bool_data() {
  if (callback_data_case() == kBoolData) {
    _impl_.callback_data_.bool_data_ = false;
    clear_has_callback_data();
  }
}
inline bool CallbackResponse::bool_data() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackResponse.bool_data)
  return _internal_bool_data();
}
inline void CallbackResponse::set_bool_data(bool value) {
  _internal_set_bool_data(value);
  // @@protoc_insertion_point(field_set:dgt.CallbackResponse.bool_data)
}
inline bool CallbackResponse::_internal_bool_data() const {
  if (callback_data_case() == kBoolData) {
    return _impl_.callback_data_.bool_data_;
  }
  return false;
}
inline void CallbackResponse::_internal_set_bool_data(bool value) {
  if (callback_data_case() != kBoolData) {
    clear_callback_data();
    set_has_bool_data();
  }
  _impl_.callback_data_.bool_data_ = value;
}

// .dgt.CallbackIIC iic_data = 5;
inline bool CallbackResponse::has_iic_data() const {
  return callback_data_case() == kIicData;
}
inline bool CallbackResponse::_internal_has_iic_data() const {
  return callback_data_case() == kIicData;
}
inline void CallbackResponse::set_has_iic_data() {
  _impl_._oneof_case_[0] = kIicData;
}
inline void CallbackResponse::clear_iic_data() {
  if (callback_data_case() == kIicData) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.callback_data_.iic_data_;
    }
    clear_has_callback_data();
  }
}
inline ::dgt::CallbackIIC* CallbackResponse::release_iic_data() {
  // @@protoc_insertion_point(field_release:dgt.CallbackResponse.iic_data)
  if (callback_data_case() == kIicData) {
    clear_has_callback_data();
    ::dgt::CallbackIIC* temp = _impl_.callback_data_.iic_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.callback_data_.iic_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dgt::CallbackIIC& CallbackResponse::_internal_iic_data() const {
  return callback_data_case() == kIicData
      ? *_impl_.callback_data_.iic_data_
      : reinterpret_cast< ::dgt::CallbackIIC&>(::dgt::_CallbackIIC_default_instance_);
}
inline const ::dgt::CallbackIIC& CallbackResponse::iic_data() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackResponse.iic_data)
  return _internal_iic_data();
}
inline ::dgt::CallbackIIC* CallbackResponse::unsafe_arena_release_iic_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dgt.CallbackResponse.iic_data)
  if (callback_data_case() == kIicData) {
    clear_has_callback_data();
    ::dgt::CallbackIIC* temp = _impl_.callback_data_.iic_data_;
    _impl_.callback_data_.iic_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CallbackResponse::unsafe_arena_set_allocated_iic_data(::dgt::CallbackIIC* iic_data) {
  clear_callback_data();
  if (iic_data) {
    set_has_iic_data();
    _impl_.callback_data_.iic_data_ = iic_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dgt.CallbackResponse.iic_data)
}
inline ::dgt::CallbackIIC* CallbackResponse::_internal_mutable_iic_data() {
  if (callback_data_case() != kIicData) {
    clear_callback_data();
    set_has_iic_data();
    _impl_.callback_data_.iic_data_ = CreateMaybeMessage< ::dgt::CallbackIIC >(GetArenaForAllocation());
  }
  return _impl_.callback_data_.iic_data_;
}
inline ::dgt::CallbackIIC* CallbackResponse::mutable_iic_data() {
  ::dgt::CallbackIIC* _msg = _internal_mutable_iic_data();
  // @@protoc_insertion_point(field_mutable:dgt.CallbackResponse.iic_data)
  return _msg;
}

inline bool CallbackResponse::has_callback_data() const {
  return callback_data_case() != CALLBACK_DATA_NOT_SET;
}
inline void CallbackResponse::clear_has_callback_data() {
  _impl_._oneof_case_[0] = CALLBACK_DATA_NOT_SET;
}
inline CallbackResponse::CallbackDataCase CallbackResponse::callback_data_case() const {
  return CallbackResponse::CallbackDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CallbackIIC

// int32 param1 = 1;
inline void CallbackIIC::clear_param1() {
  _impl_.param1_ = 0;
}
inline ::int32_t CallbackIIC::param1() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackIIC.param1)
  return _internal_param1();
}
inline void CallbackIIC::set_param1(::int32_t value) {
  _internal_set_param1(value);
  // @@protoc_insertion_point(field_set:dgt.CallbackIIC.param1)
}
inline ::int32_t CallbackIIC::_internal_param1() const {
  return _impl_.param1_;
}
inline void CallbackIIC::_internal_set_param1(::int32_t value) {
  ;
  _impl_.param1_ = value;
}

// int32 param2 = 2;
inline void CallbackIIC::clear_param2() {
  _impl_.param2_ = 0;
}
inline ::int32_t CallbackIIC::param2() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackIIC.param2)
  return _internal_param2();
}
inline void CallbackIIC::set_param2(::int32_t value) {
  _internal_set_param2(value);
  // @@protoc_insertion_point(field_set:dgt.CallbackIIC.param2)
}
inline ::int32_t CallbackIIC::_internal_param2() const {
  return _impl_.param2_;
}
inline void CallbackIIC::_internal_set_param2(::int32_t value) {
  ;
  _impl_.param2_ = value;
}

// string param3 = 3;
inline void CallbackIIC::clear_param3() {
  _impl_.param3_.ClearToEmpty();
}
inline const std::string& CallbackIIC::param3() const {
  // @@protoc_insertion_point(field_get:dgt.CallbackIIC.param3)
  return _internal_param3();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CallbackIIC::set_param3(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.param3_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dgt.CallbackIIC.param3)
}
inline std::string* CallbackIIC::mutable_param3() {
  std::string* _s = _internal_mutable_param3();
  // @@protoc_insertion_point(field_mutable:dgt.CallbackIIC.param3)
  return _s;
}
inline const std::string& CallbackIIC::_internal_param3() const {
  return _impl_.param3_.Get();
}
inline void CallbackIIC::_internal_set_param3(const std::string& value) {
  ;


  _impl_.param3_.Set(value, GetArenaForAllocation());
}
inline std::string* CallbackIIC::_internal_mutable_param3() {
  ;
  return _impl_.param3_.Mutable( GetArenaForAllocation());
}
inline std::string* CallbackIIC::release_param3() {
  // @@protoc_insertion_point(field_release:dgt.CallbackIIC.param3)
  return _impl_.param3_.Release();
}
inline void CallbackIIC::set_allocated_param3(std::string* value) {
  _impl_.param3_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.param3_.IsDefault()) {
          _impl_.param3_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dgt.CallbackIIC.param3)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace dgt


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_dgtdll_2eproto_2epb_2eh
