@page "/background.html"
@inherits BackgroundPage
@inject IScriptWrapper Scripts
@inject IAppData AppDataService
@inject IChessDotComWatcher ChessDotComWatcher
@inject IChessDotComHelpers ChessDotComHelpers
@inject IDgtLiveChess DgtLiveChess
@inject HttpClient WebClient
@using DgtAngel.Services
@using WebExtensions.Net.Tabs
@using DgtAngelLib
@using System.Threading

<div>
@foreach(var item in Enum.GetValues(typeof(ScriptWrapper.AudioClip)))
    {
        <audio preload="auto" type="audio/wav" id="@(Scripts.GetAudioFileId((ScriptWrapper.AudioClip)item))" src="@(Scripts.GetAudioFileSrc((ScriptWrapper.AudioClip)item))" autostart="false"></audio>
    }
</div>

@code {

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"Starting....");
        await Scripts.AddIndexToContextMenu();
        await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"Context Menu Item Added");

        Task pollChessDotComBoardTask = null;
        CancellationTokenSource canxSrcChessDotComBoardPoll = null;
        bool hasOnLiveChessConnectedPlayedSinceLastConnection = true; //Set to true so audio does not play on startup


        DgtLiveChess.OnLiveChessConnected += async (obj, eventArgs) =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"DGT_BOARD:{eventArgs.ResponseOut}");
                                await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.DGT_LC_CONNECTED);
                            };

        DgtLiveChess.OnLiveChessDisconnected += async (obj, eventArgs) =>
                            {
                                //Only play/log if we were previously connected
                                if (!hasOnLiveChessConnectedPlayedSinceLastConnection)
                                {
                                    await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"DGT_BOARD:{eventArgs.ResponseOut}");
                                    await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.DGT_LC_DISCONNECTED);
                                    await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"Trying to connect to Live Chess");
                                    hasOnLiveChessConnectedPlayedSinceLastConnection = true;
                                }                                    
                            };

        DgtLiveChess.OnBoardConnected += async (obj, eventArgs) =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"DGT_BOARD:{eventArgs.ResponseOut}");
                                await WebExtensions.BrowserAction.SetIcon(new WebExtensions.Net.BrowserAction.SetIconDetails() { Path = "Icons/Connected/icon-48.png" });
                                await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.DGT_CONNECTED);

                                //Run the Chess.Com Watcher
                                #pragma warning disable CS4014 // This functions does not return without cancelation - NEVER AWAIT
                                canxSrcChessDotComBoardPoll = new CancellationTokenSource();
                                pollChessDotComBoardTask = ChessDotComWatcher.PollChessDotComBoard(canxSrcChessDotComBoardPoll.Token);
                                hasOnLiveChessConnectedPlayedSinceLastConnection = false;
                                #pragma warning restore CS4014
                            };

        DgtLiveChess.OnBoardDisconnected += async (obj, eventArgs) =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"DGT_BOARD:{eventArgs.ResponseOut}");
                                await WebExtensions.BrowserAction.SetIcon(new WebExtensions.Net.BrowserAction.SetIconDetails() { Path = "Icons/Default/icon-48.png" });
                                await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.DGT_DISCONNECTED);

                                //Stop the Chess.Com Watcher (if running) 
                                canxSrcChessDotComBoardPoll?.Cancel();
                            };

        DgtLiveChess.OnResponseRecieved += async (obj, eventArgs) =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"DGT_BOARD:{eventArgs.ResponseOut}");
                                AppDataService.BoardFEN = eventArgs.ResponseOut;
                            };

        ChessDotComWatcher.OnFenRecieved += async (obj, eventArgs) =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.DEBUG, "BACKGROUND", $"CDC_WATCH:{eventArgs.FenString}");
                                AppDataService.ChessDotComFEN = eventArgs.FenString;
                                AppDataService.SetClocks(eventArgs.WhiteClock, eventArgs.BlackClock, eventArgs.ToMove);
                            };

        ChessDotComWatcher.OnWatchStarted += async (obj, eventArgs) =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"Watching the https://www.chess.com/live tab has started");
                                await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.CDC_WATCHING);
                            };

        ChessDotComWatcher.OnWatchStopped += async (obj, eventArgs) =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"Watching the https://www.chess.com/live tab has stopped");
                                await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.CDC_NOTWATCHING);

                                await WebClient.SendAsync(new HttpRequestMessage() { RequestUri = new Uri($"http://localhost:37964/ClockApi/SetAuthors/0:00:00/0:00:00/9") });

                                AppDataService.ResetChessDotComBoardState();
                            };
/*
        AppDataService.OnFenChange += async () =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.DEBUG, "BACKGROUND", $"APP_DATA: Matching {AppDataService.ChessDotComFEN} {AppDataService.BoardFEN}");

                                if (AppDataService.IsChessDotComBoardStateActive && AppDataService.ChessDotComFEN != AppDataService.BoardFEN)
                                {
                                    //Give time to move the pieces in sync...
                                    await Task.Delay(2000);

                                    //...then test again
                                    if (AppDataService.IsChessDotComBoardStateActive && AppDataService.ChessDotComFEN != AppDataService.BoardFEN)
                                    {
                                        await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"APP_DATA: Mismatch detected...Boards are not in sync");
                                        await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.MISMATCH);
                                    }
                                    else
                                    {
                                        await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"APP_DATA: The boards are in sync");
                                        await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.MATCH);
                                    }
                                }
                                else
                                {
                                    await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"APP_DATA: The boards are in sync");
                                    await Scripts.PlayAudioFile(ScriptWrapper.AudioClip.MATCH);
                                }
                            };

                            */

        AppDataService.OnClockChange += async () =>
                            {
                                await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"APP_DATA: White Clock {AppDataService.WhiteClock} Black Clock {AppDataService.BlackClock} To Move {AppDataService.ToMove}");

                                var ws = AppDataService.WhiteClock.Split(".")[0].Split(":");
                                var bc = AppDataService.BlackClock.Split(".")[0].Split(":");

                                string wcout = $"0:{ws[0].PadLeft(2,'0')}:{ws[1].PadLeft(2,'0')}";
                                string bcout = $"0:{bc[0].PadLeft(2,'0')}:{bc[1].PadLeft(2,'0')}";
                                string toMove = ((AppDataService.ToMove.ToUpper() == "W") ? "1" : ((AppDataService.ToMove.ToUpper() == "B")?"2":"0"));

                                await WebClient.SendAsync(new HttpRequestMessage() { RequestUri = new Uri($"http://localhost:37964/ClockApi/SetAuthors/{wcout}/{bcout}/{toMove}")});
                                /*
                                using var client = new System.Net.Sockets.TcpClient("localhost", 13000);
                                var netStream = client.GetStream();
                                var txtstream = new System.IO.StreamWriter(netStream);
                                await txtstream.WriteLineAsync($"TXT,{AppDataService.WhiteClock}");
                                await txtstream.WriteLineAsync($"QUIT");
                                */

                            };



                                

#pragma warning disable CS4014 // This function does not return - NEVER AWAIT
        await Scripts.WriteToConsole(ScriptWrapper.LogLevel.INFO, "BACKGROUND", $"Trying to connect to Live Chess (Startup)");
        DgtLiveChess.PollDgtBoard();
#pragma warning restore CS4014




    }
}
